<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Continuous-time deterministic dynamic programming in Julia</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="generator" content="Hugo 0.21" />
    <link rel="stylesheet" type="text/css" href="../../css/style.css">
    <link rel="stylesheet" type="text/css" href="../../css/lovelace.css">
    
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['$','$'], ['\\(','\\)']],
          displayMath: [['$$','$$'], ['\[','\]']],
          processEscapes: true,
          processEnvironments: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
          TeX: { equationNumbers: { autoNumber: "AMS" },
               extensions: ["AMSmath.js", "AMSsymbols.js"] }
        }
      });
    </script>
    <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
  </head>
  <body>
    <nav id="navbar">
      <a href="http://tpapp.github.io/">About</a>
<a href="http://tpapp.github.io/research">Research</a>
<a href="http://tpapp.github.io/post">Blog</a>
<a href="http://tpapp.github.io/software">Software</a>
<a href="https://github.com/tpapp/">Github</a>

    </nav>
    <div id="navbarplaceholder">
      <a href="http://tpapp.github.io/">About</a>
<a href="http://tpapp.github.io/research">Research</a>
<a href="http://tpapp.github.io/post">Blog</a>
<a href="http://tpapp.github.io/software">Software</a>
<a href="https://github.com/tpapp/">Github</a>

    </div>
    <div id="mainbody">
<div id="sidebar">
  
  <a href="../../tags/bayesian">bayesian</a>
  
  <a href="../../tags/blogging">blogging</a>
  
  <a href="../../tags/browser-plugins">browser-plugins</a>
  
  <a href="../../tags/economics">economics</a>
  
  <a href="../../tags/emacs-emacs25-ubuntu">emacs-emacs25-ubuntu</a>
  
  <a href="../../tags/firefox">firefox</a>
  
  <a href="../../tags/hugo">hugo</a>
  
  <a href="../../tags/jacobian">jacobian</a>
  
  <a href="../../tags/julia">julia</a>
  
  <a href="../../tags/latex">latex</a>
  
  <a href="../../tags/math">math</a>
  
  <a href="../../tags/mcmc">mcmc</a>
  
  <a href="../../tags/my-packages">my-packages</a>
  
  <a href="../../tags/numerical-methods">numerical-methods</a>
  
  <a href="../../tags/stan">stan</a>
  
  <a href="../../tags/teaching">teaching</a>
  
  <a href="../../tags/tutorial">tutorial</a>
  
  <a href="../../tags/weave">weave</a>
  
</div>

<div id="content">
<h1>Continuous-time deterministic dynamic programming in Julia</h1>2017/04/02
<span class="tags">
    
    <a href="../../tags/julia">julia</a>
    
    <a href="../../tags/economics">economics</a>
    
    <a href="../../tags/tutorial">tutorial</a>
    
    <a href="../../tags/numerical-methods">numerical methods</a>
    
    <a href="../../tags/my-packages">my packages</a>
    
</span>





<p>For the past few weeks I have been organizing pieces of code I have used to solve economic models into Julia packages. <a href="https://github.com/tpapp/EconFunctions.jl">EconFunctions.jl</a> is a collection of trivial functions that I noticed that I kept recoding/copy-pasting everywhere, occasionally making errors. <a href="https://github.com/tpapp/ContinuousTransformations.jl">ContinuousTransformations.jl</a> is a library for manipulating various commonly used homeomorphisms (univariate at the moment), which are useful in functional equations or Markov Chain Monte Carlo. Finally <a href="https://github.com/tpapp/ParametricFunctions.jl">ParametricFunctions.jl</a> is for working with parametric function families.</p>

<p>In this post I use these three to solve a simple, deterministic dynamic programming model in continuous time, known as the Ramsey growth model. If you are not an economist, it is very unlikely that it will make a lot of sense. If you are a student, I added basic references at the end, which are consistent with the methods in this post.</p>

<p><strong>Caveat</strong>: <em>these libraries are in development, I am refining the API and changing things all the time. It is very likely that as time progresses, code in this post will not run without changes.</em> In other words, treat this as a sneak peak into a library which is in development.</p>

<h2 id="theory">Theory</h2>

<p>This is standard material, I am just repeating it so that this post is self-contained. We solve</p>

<p>$$\max \int_0^\infty e^{-\rho t} u(c_t) dt$$
subject to
$$\dot{k}_t = F(k_t) - c_t, k_t \ge 0 \forall t.$$</p>

<p>where $u( c )$ is a CRRA utility function with IES $\theta$, $F(k) = A k^\alpha - \delta k$ is a production function that accounts for depreciation. Our problem is described by the Hamilton-Jacobi-Bellman equation</p>

<p>$$\rho V(k) = \max_c u( c ) + (F(k)-c) V&rsquo;(k)$$</p>

<p>Notice that once we have $V$, the first-order condition</p>

<p>$$u&rsquo;(c(k)) = V&rsquo;(k)$$</p>

<p>yields the policy function $c(k)$, which we are interested in. Combining the envelope condition</p>

<p>$$\rho V&rsquo;(k) = F&rsquo;(k) V&rsquo;(k) + (F(k)-c) V{&lsquo;}{&rsquo;}(k)$$</p>

<p>and using the functional form for CRRA utility, we obtain</p>

<p>$$\frac{c&rsquo;(k)}{c(k)} (F(k)-c(k)) = \frac{1}{\theta} (F&rsquo;(k)-\rho)$$</p>

<p>which is a recursive form of the so-called Euler equation.</p>

<p>Also, note that we can characterize the steady state capital and consumption by</p>

<p>$$k_s = \left(\frac{\delta+\rho}{A\alpha}\right)^{1/(\alpha-1)}$$</p>

<p>and</p>

<p>$$c_s = F(k_s)$$</p>

<h2 id="julia-code-solving-the-euler-equation">Julia code: solving the Euler equation</h2>

<p>Load the libraries (you need to clone some code, as the packages are not registered).</p>
<div class="highlight"><pre><code class="language-julia" data-lang="julia"><span></span><span class="k">using</span> <span class="n">ParametricFunctions</span>       <span class="c"># unregistered, clone from repo</span>
<span class="k">using</span> <span class="n">ContinuousTransformations</span> <span class="c"># unregistered, clone from repo</span>
<span class="k">using</span> <span class="n">EconFunctions</span>             <span class="c"># unregistered, clone from repo</span>
<span class="k">using</span> <span class="n">Plots</span><span class="p">;</span> <span class="n">gr</span><span class="p">()</span>
<span class="k">using</span> <span class="n">Parameters</span>
<span class="k">using</span> <span class="n">NLsolve</span>
</code></pre></div>

<p>It is useful to put model parameters in a single structure.</p>
<div class="highlight"><pre><code class="language-julia" data-lang="julia"><span></span><span class="s">&quot;&quot;&quot;</span>
<span class="s">Very simple (normalized) Ramsey model with isoelastic production</span>
<span class="s">function and utility.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="p">@</span><span class="n">with_kw</span> <span class="k">immutable</span> <span class="n">RamseyModel</span><span class="p">{</span><span class="n">T</span><span class="p">}</span>
    <span class="n">θ</span><span class="p">::</span><span class="n">T</span>                        <span class="c"># IES</span>
    <span class="n">α</span><span class="p">::</span><span class="n">T</span>                        <span class="c"># capital share</span>
    <span class="n">A</span><span class="p">::</span><span class="n">T</span>                        <span class="c"># TFP</span>
    <span class="n">ρ</span><span class="p">::</span><span class="n">T</span>                        <span class="c"># discount rate</span>
    <span class="n">δ</span><span class="p">::</span><span class="n">T</span>                        <span class="c"># depreciation</span>
<span class="k">end</span>
</code></pre></div>

<p>This is the key part: we code the residual for the Euler equation. The function should take the model (which contains the parameters), a function $c$ that has been constructed using a function family and a set of parameters, and a scalar $k$, at which we evaluate the residual above. Everything else can be automated very well.</p>
<div class="highlight"><pre><code class="language-julia" data-lang="julia"><span></span><span class="s">&quot;&quot;&quot;</span>
<span class="s">Residual of the Euler equation.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="k">function</span><span class="nf"> euler_residual</span><span class="p">(</span><span class="n">model</span><span class="p">::</span><span class="n">RamseyModel</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="p">@</span><span class="n">unpack</span> <span class="n">θ</span><span class="p">,</span> <span class="n">ρ</span><span class="p">,</span> <span class="n">α</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">δ</span> <span class="o">=</span> <span class="n">model</span>
    <span class="n">Fk</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">k</span><span class="o">^</span><span class="n">α</span> <span class="o">-</span> <span class="n">δ</span><span class="o">*</span><span class="n">k</span>
    <span class="n">F′k</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">α</span><span class="o">*</span><span class="n">k</span><span class="o">^</span><span class="p">(</span><span class="n">α</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">δ</span>
    <span class="n">ck</span><span class="p">,</span> <span class="n">c′k</span> <span class="o">=</span> <span class="n">c</span><span class="p">(</span><span class="n">ValuePartial</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
    <span class="p">(</span><span class="n">c′k</span><span class="o">/</span><span class="n">ck</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Fk</span><span class="o">-</span><span class="n">ck</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">θ</span><span class="o">*</span><span class="p">(</span><span class="n">F′k</span><span class="o">-</span><span class="n">ρ</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>

<p>Above, <code>c</code> can be treated like an ordinary function, except that if you call it with <code>ValuePartial(x)</code>, you get the value <em>and</em> the derivative.</p>

<p>The steady state will be handy:</p>
<div class="highlight"><pre><code class="language-julia" data-lang="julia"><span></span><span class="s">&quot;Return the steady state capital and consumption for the model.&quot;</span>
<span class="k">function</span><span class="nf"> steady_state</span><span class="p">(</span><span class="n">model</span><span class="p">::</span><span class="n">RamseyModel</span><span class="p">)</span>
    <span class="p">@</span><span class="n">unpack</span> <span class="n">α</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">ρ</span><span class="p">,</span> <span class="n">δ</span> <span class="o">=</span> <span class="n">model</span>
    <span class="n">k</span> <span class="o">=</span> <span class="p">((</span><span class="n">δ</span><span class="o">+</span><span class="n">ρ</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">α</span><span class="p">))</span><span class="o">^</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">α</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">k</span><span class="o">^</span><span class="n">α</span> <span class="o">-</span> <span class="n">δ</span><span class="o">*</span><span class="n">k</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">c</span>
<span class="k">end</span>
</code></pre></div>

<p>Let&rsquo;s make a model object (parameters are pretty standard), and calculate the steady state:</p>
<div class="highlight"><pre><code class="language-julia" data-lang="julia"><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">RamseyModel</span><span class="p">(</span><span class="n">θ</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">α</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">ρ</span> <span class="o">=</span> <span class="mf">0.02</span><span class="p">,</span> <span class="n">δ</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">)</span>

<span class="n">kₛ</span><span class="p">,</span> <span class="n">cₛ</span> <span class="o">=</span> <span class="n">steady_state</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</code></pre></div>

<p>We will solve in a domain around the steady state capital.</p>
<div class="highlight"><pre><code class="language-julia" data-lang="julia"><span></span><span class="n">kdom</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">kₛ</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">kₛ</span><span class="p">)</span>
</code></pre></div>

<p>Given the pieces above, obtaining the solution can be done very conscisely: create a residual object, which is basically a mapping from parameters to the function family to the residuals:</p>
<div class="highlight"><pre><code class="language-julia" data-lang="julia"><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">CollocationResidual</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">DomainTrans</span><span class="p">(</span><span class="n">kdom</span><span class="p">,</span> <span class="n">Chebyshev</span><span class="p">(</span><span class="mi">10</span><span class="p">)),</span>
                          <span class="n">euler_residual</span><span class="p">)</span>
</code></pre></div>

<p>The above say that we want 10 Chebyshev polynomials, transformed to the domain <code>kdom</code>, to be used for constructing the $c(k)$.</p>

<p>We call the solver, providing an initial guess, $c(k) = k\cdot c_s/k_s$, for the policy function $c(k)$. The guess is that consumption is linear in capital, and the line goes through the steady state values. Other reasonable guesses are possible, but note that it is worthwhile thinking a bit about a good one, so that you get fast convergence.</p>

<p>The function below fits a parametric function from the given family to the initial guess, then solves for the residual being $0$ using <code>NLsolve</code> with automatic differentiation under the hood.</p>
<div class="highlight"><pre><code class="language-julia" data-lang="julia"><span></span><span class="n">c_sol</span><span class="p">,</span> <span class="n">o</span> <span class="o">=</span> <span class="n">solve_collocation</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">cₛ</span><span class="o">*</span><span class="n">k</span><span class="o">/</span><span class="n">kₛ</span><span class="p">;</span> <span class="n">ftol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span>
                             <span class="n">method</span> <span class="o">=</span> <span class="p">:</span><span class="n">newton</span><span class="p">)</span>
</code></pre></div>

<p>Convergence statistics:</p>

<pre><code>Results of Nonlinear Solver Algorithm
 * Algorithm: Newton with line-search
 * Starting Point: [1.83249,1.09949,7.10543e-16,4.44089e-16,-1.77636e-16,-8
.88178e-17,-8.43769e-16,1.64313e-15,1.33227e-16,3.10862e-16]
 * Zero: [1.57794,0.433992,-0.0360164,0.00624848,-0.00134301,0.000320829,-8
.21347e-5,2.28742e-5,-6.85183e-6,1.48105e-6]
 * Inf-norm of residuals: 0.000000
 * Iterations: 6
 * Convergence: true
   * |x - x'| &lt; 0.0e+00: false
   * |f(x)| &lt; 1.0e-10: true
 * Function Calls (f): 7
 * Jacobian Calls (df/dx): 6
</code></pre>

<p>Overall, pretty good, very few iterations. We plot the resulting function:</p>
<div class="highlight"><pre><code class="language-julia" data-lang="julia"><span></span><span class="n">plot</span><span class="p">(</span><span class="n">c_sol</span><span class="p">,</span> <span class="n">xlab</span> <span class="o">=</span> <span class="s">&quot;k&quot;</span><span class="p">,</span> <span class="n">ylab</span> <span class="o">=</span> <span class="s">&quot;c(k)&quot;</span><span class="p">,</span> <span class="n">legend</span> <span class="o">=</span> <span class="n">false</span><span class="p">)</span>
<span class="n">scatter!</span><span class="p">([</span><span class="n">kₛ</span><span class="p">],</span> <span class="p">[</span><span class="n">cₛ</span><span class="p">])</span>
</code></pre></div>


<figure >
    
        <img src="../figures/dynamic-programming_10_1.svg" />
    
    
</figure>


<p>Notive how the collocation nodes are added automatically (this is done with a plot recipe). It should, of course, go thought the steady state.</p>

<p>It is very important to plot the residual:</p>
<div class="highlight"><pre><code class="language-julia" data-lang="julia"><span></span><span class="n">plot</span><span class="p">(</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">euler_residual</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">c_sol</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">linspace</span><span class="p">(</span><span class="n">kdom</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
     <span class="n">legend</span> <span class="o">=</span> <span class="n">false</span><span class="p">,</span> <span class="n">xlab</span><span class="o">=</span><span class="s">&quot;k&quot;</span><span class="p">,</span> <span class="n">ylab</span><span class="o">=</span><span class="s">&quot;Euler residual&quot;</span><span class="p">)</span>
<span class="n">scatter!</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">points</span><span class="p">(</span><span class="n">c_sol</span><span class="p">))</span>
</code></pre></div>


<figure >
    
        <img src="../figures/dynamic-programming_11_1.svg" />
    
    
</figure>


<p>Note the near-equioscillation property, which you get from using Chebyshev polynomials. You get $10^{-6}$ accuracy, which is neat (but note that this is a simple textbook problem, very smooth and tractable).</p>

<h2 id="selected-reading">Selected reading</h2>

<p>Acemoglu, Daron. Introduction to modern economic growth. Princeton University Press, 2008. <em>Chapter 8.</em></p>

<p>Miranda, Mario J., and Paul L. Fackler. Applied computational economics and finance. MIT press, 2004. <em>Chapters 10 and 11</em>.</p>



<div id="pagenav">
  
  <span class="pagenav-label">Previous</span>
  <a href="http://tpapp.github.io/post/blogging-weave-julia-hugo/">Blogging with Hugo, Julia, Weave.jl</a>
  
  
  <span class="pagenav-label">Next</span>
  <a href="http://tpapp.github.io/post/privacy-badger/">Disabling Privacy Badger</a>
  
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'tpappgithubio';
    var disqus_identifier = 'http:\/\/tpapp.github.io\/post\/dynamic-programming\/';
    var disqus_title = 'Continuous-time deterministic dynamic programming in Julia';
    var disqus_url = 'http:\/\/tpapp.github.io\/post\/dynamic-programming\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

    </div>
  </body>
</html>

