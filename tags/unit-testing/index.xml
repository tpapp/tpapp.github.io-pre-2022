<feed xmlns="http://www.w3.org/2005/Atom">
  <title>unit-testing on Tamás K. Papp&#39;s website</title>
  <link href="https://tamaspapp.eu/index.xml" rel="self"/>
  <link href="https://tamaspapp.eu/tags/unit-testing/"/>
  <updated>2019-09-07T08:01:57+02:00</updated>
  
  <id>https://tamaspapp.eu/tags/unit-testing/</id>
  <author>
    <name>Tamás K. Papp</name>
  </author>
  <generator>Hugo -- gohugo.io</generator>
  
  <entry>
    <title type="html">How my Julia coding style changed</title>
    <link href="https://tamaspapp.eu/post/2019-09-07-coding_style_retrospective/"/>
    <id>https://tamaspapp.eu/post/2019-09-07-coding_style_retrospective/</id>
    <published>2019-09-07T08:01:57+02:00</published>
    <updated>2019-09-07T08:01:57+02:00</updated>
    
    <content type="html" xml:base="https://tamaspapp.eu/post/2019-09-07-coding_style_retrospective/">&lt;p&gt;The &lt;a href=&#34;https://tamaspapp.eu/post/2019-08-29-dynamichmc2/&#34;&gt;recent redesign&lt;/a&gt; of &lt;a href=&#34;https://github.com/tpapp/DynamicHMC.jl&#34;&gt;DynamicHMC.jl&lt;/a&gt; provides an opportunity to reflect on how my Julia coding style changed. I started this package two years ago, and did not do any major refactoring after it became usable, mostly because I did not have a good comprehensive test suite or a solid conceptual understanding of &lt;em&gt;all&lt;/em&gt; the ramifications of the algorithm, especially the adaptation, and I was afraid of breaking something that I just got working. Consequently, the code before the redesign largely reflected the coding style I developed for Julia 0.5 and then partly 0.6.&lt;/p&gt;

&lt;p&gt;I am one of those people who recognize the benefits of reflecting on the past from time to time, but are too &lt;del&gt;busy&lt;/del&gt; lazy to keep a diary. But code under version control is effectively a diary about the life of software, and I find it interesting to think about how my Julia coding style has changed in the past to years.&lt;/p&gt;

&lt;p&gt;It is important to emphasize that this writeup reflects how &lt;em&gt;I&lt;/em&gt; code &lt;em&gt;at the moment&lt;/em&gt;. I recognize that other coding styles in Julia can be perfectly legitimate, and when I contribute to packages, I do my best to follow existing style. Also, it is very likely that my own coding style will change as the language evolves. In this blog post, I won&#39;t address details of coding style about which there is a more or less general agreement --- see &lt;a href=&#34;https://docs.julialang.org/en/v1.4-dev/manual/style-guide/&#34;&gt;the Style Guide in the manual&lt;/a&gt; and &lt;a href=&#34;https://github.com/jrevels/YASGuide&#34;&gt;YASGuide&lt;/a&gt; for useful summaries. Finally, some examples are stylized adaptations of real code for simpler exposition.&lt;/p&gt;

&lt;h1 id=&#34;randomness&#34;&gt;Randomness&lt;/h1&gt;

&lt;p&gt;Random numbers are very important for scientific computing, but at the same time present an important challenge for writing bug-free parallel code and unit testing. A lot of code in &lt;code&gt;Random&lt;/code&gt; and &lt;code&gt;Base&lt;/code&gt; follows the interface conventions&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span class=&#34;n&#34;&gt;rand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rng&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;making the random number generator an &lt;em&gt;optional&lt;/em&gt; first argument, and defaulting to the global one.&lt;/p&gt;

&lt;p&gt;While this can be convenient for &lt;em&gt;user code&lt;/em&gt;, in &lt;em&gt;packages&lt;/em&gt; I find that it is better to keep the random number generator as an &lt;em&gt;explicit&lt;/em&gt; argument to almost all methods. This paves the way for making the code work nicely with &lt;a href=&#34;https://julialang.org/blog/2019/07/multithreading&#34;&gt;composable multi-threading&lt;/a&gt; too.&lt;/p&gt;

&lt;p&gt;If random and deterministic parts of the algorithm can be separated, it should be done, as it usually makes the code cleaner, and unit testing much easier. An example of this is factoring out the &lt;a href=&#34;https://github.com/tpapp/DynamicHMC.jl/blob/20665c2010f76f8b048477491018d02a51b3b35d/src/trees.jl#L19&#34;&gt;random directions for tree doubling&lt;/a&gt; in NUTS: drawing a single set of bit flags &lt;em&gt;once&lt;/em&gt; and providing this to the tree building algorithm, the latter can treat the doubling directions as predetermined. This also made it much easier to verify detailed balance in the unit tests.&lt;/p&gt;

&lt;h1 id=&#34;named-tuples&#34;&gt;Named tuples&lt;/h1&gt;

&lt;p&gt;Named tuples are extremely useful for organizing multiple values as inputs and outputs when a composite type (&lt;code&gt;struct&lt;/code&gt;) is not warranted or needed. If a function returns multiple values, especially more than two, I now always default to using named tuples, ie&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then use &lt;code&gt;@unpack&lt;/code&gt; from &lt;a href=&#34;https://github.com/mauro3/Parameters.jl&#34;&gt;Parameters.jl&lt;/a&gt; for destructuring:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@unpack&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c&#34;&gt;# I don&amp;#39;t need c here&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is costless and makes the interfaces more flexible: for example, I can add extra fields, or eventually make the returned value a composite type later, without changing anything in the callers.&lt;/p&gt;

&lt;h1 id=&#34;multiliners-as-opposed-to-oneliners&#34;&gt;Multi-liners as opposed to one-liners&lt;/h1&gt;

&lt;p&gt;Almost all the “clever” one liners are now expunged from the code. Compare&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span class=&#34;n&#34;&gt;EBFMI&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;πs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;π&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mean&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;abs2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;diff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;πs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;πs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;with&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EBFMI&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tree_statistics&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;πs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;π&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree_statistics&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;mean&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;abs2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;diff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;πs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;πs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first one is kind of crammed, and difficult to read, while the second one makes it clear that an interim value is obtained for the calculation.&lt;/p&gt;

&lt;p&gt;When a function returns multiple values, I find it nice to assign each to a variable first, ie&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;as opposed to&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This makes the returned structure much more readable when I need to look at some code later.&lt;/p&gt;

&lt;p&gt;That said, I still have a strong preference for writing small functions that “do one thing”. This again is frequently an optimal strategy for Julia, as the compiler is very good about inlining decisions (and when not, can be nudged with &lt;code&gt;@inline&lt;/code&gt;).&lt;/p&gt;

&lt;h1 id=&#34;abstract-types-can-be-an-implementation-detail&#34;&gt;Abstract types can be an implementation detail&lt;/h1&gt;

&lt;p&gt;Abstract types can be very useful for organizing method dispatch: code like&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span class=&#34;k&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SomeAbstractType&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;end&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SomeAbstractType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;do_something&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ThatSubType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SomeAbstractType&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;end&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ThatSubType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;do_something_else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;can help avoid repetition.&lt;/p&gt;

&lt;p&gt;But abstract types are just &lt;em&gt;one&lt;/em&gt; convenient tool for this, and building a type tree is a tool, not an end in itself. When they are no longer adequate, other solutions such as &lt;a href=&#34;https://docs.julialang.org/en/v1.4-dev/manual/methods/#Trait-based-dispatch-1&#34;&gt;traits&lt;/a&gt; should be used instead.&lt;/p&gt;

&lt;p&gt;Consequently, these days I mostly consider type hierarchies an implementation detail and I am wary of exposing them in the API of a package. This is especially important if some functionality requires that the &lt;em&gt;user&lt;/em&gt; of a package implements their own custom types, e.g. for a model. Requiring that&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span class=&#34;n&#34;&gt;UserDefinedModel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SomePackage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ModelType&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to work with some API is usually &lt;em&gt;unnecessary&lt;/em&gt;, and can cause unnecessary complications when the user would want &lt;code&gt;UserDefinedModel&lt;/code&gt; to implement some &lt;em&gt;other&lt;/em&gt; API. Either &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34;&gt;duck typing&lt;/a&gt;, or an explicit interface check like&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span class=&#34;n&#34;&gt;implements_model&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;Any&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;implements_model&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;UserDefinedModel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;can work better (returning types when that is necessary, eg for further dispatch — see &lt;code&gt;Base.IteratorSize&lt;/code&gt; for an example).&lt;/p&gt;

&lt;h1 id=&#34;small-type-unions&#34;&gt;Small type unions&lt;/h1&gt;

&lt;p&gt;The ability of the compiler create efficient code for &lt;a href=&#34;https://julialang.org/blog/2018/08/union-splitting&#34;&gt;small type unions&lt;/a&gt; made code organization much easier for me. For example, &lt;a href=&#34;https://github.com/tpapp/DynamicHMC.jl/blob/20665c2010f76f8b048477491018d02a51b3b35d/src/trees.jl#L197&#34;&gt;&lt;code&gt;DynamicHMC.adjacent_tree&lt;/code&gt;&lt;/a&gt; attempts to build a tree next to some position, but this can fail because of divergence or turning in the leapfrog integrator, in which case it is useful to bail out early and return information about the reason. Consequently, this function either returns a tree, or an &lt;code&gt;InvalidTree&lt;/code&gt;, which is a container with the aforementioned diagnostic information. The compiler recognizes this and generates fast code.&lt;/p&gt;

&lt;p&gt;Some attention should be paid to avoid combinatoric type explosions, but when used well, small type unions can make code much simpler at little or no extra cost.&lt;/p&gt;

&lt;h1 id=&#34;functional-is-often-the-best-solution&#34;&gt;Functional is often the best solution&lt;/h1&gt;

&lt;p&gt;Preallocating containers for outputs &lt;a href=&#34;https://docs.julialang.org/en/v1.4-dev/manual/performance-tips/#Pre-allocating-outputs-1&#34;&gt;can make code faster&lt;/a&gt;, but at the cost of extra complexity, especially that of having to figure out type parameters for said containers.&lt;/p&gt;

&lt;p&gt;My general strategy is to write code in a &lt;a href=&#34;https://en.wikipedia.org/wiki/Functional_programming&#34;&gt;functional&lt;/a&gt;, side-effect-free style until I am really convinced that preallocation would help, and then confine it to carefully compartmentalized parts of the code. This is of course ideal only for &lt;em&gt;some&lt;/em&gt; kinds of code — when &lt;a href=&#34;http://www.stochasticlifestyle.com/when-do-micro-optimizations-matter-in-scientific-computing/&#34;&gt;allocations dominate&lt;/a&gt;, a functional style is not optimal.&lt;/p&gt;

&lt;p&gt;That said, Julia&#39;s compiler is getting more and more clever about optimizing allocations, so I frequently find that I never rewrite code with preallocated containers, and occasionally even revert from preallocated code to a functional style without a relevant performance cost.&lt;/p&gt;

&lt;h1 id=&#34;when-in-doubt-document&#34;&gt;When in doubt, document&lt;/h1&gt;

&lt;p&gt;Some readers of the code of &lt;a href=&#34;https://github.com/tpapp/DynamicHMC.jl&#34;&gt;DynamicHMC.jl&lt;/a&gt; will have the impression that it is &lt;em&gt;overdocumented&lt;/em&gt;. Probably 20–25% of the lines in the source are docstrings, and most internal interfaces and convenience functions have one.&lt;/p&gt;

&lt;p&gt;Primarily, this is driven by instances of the embarassing realization of having written some code two years ago which kind of works, but no longer being sure of all the details that would be nice to know before refactoring. But another consideration is encouraging contributions, or uses of the packages for research — besides being an implementation of the NUTS sampler, &lt;a href=&#34;https://github.com/tpapp/DynamicHMC.jl&#34;&gt;DynamicHMC.jl&lt;/a&gt; is also a platform for experimenting, which is easier to do when the internals are documented.&lt;/p&gt;

&lt;p&gt;Julia&#39;s documentation ecosystem is now very mature and robust. Besides the excellent &lt;a href=&#34;https://github.com/JuliaDocs/Documenter.jl&#34;&gt;Documenter.jl&lt;/a&gt;, I also find &lt;a href=&#34;https://github.com/JuliaDocs/DocStringExtensions.jl&#34;&gt;DocStringExtensions.jl&lt;/a&gt; very useful.&lt;/p&gt;

&lt;h1 id=&#34;internal-interfaces-have-high-return-on-investment&#34;&gt;Internal interfaces have high return on investment&lt;/h1&gt;

&lt;p&gt;Many packages, especially those that are work in progress or experimental, do not document their &lt;em&gt;user&lt;/em&gt; interfaces very carefully. This is of course understandable, but I have developed a preference for abstracting out and documenting interfaces in &lt;em&gt;internally used code&lt;/em&gt;, too, as the package matures.&lt;/p&gt;

&lt;p&gt;This makes refactoring and compartmentalization much easier, and makes sense even if a particular interface has only a &lt;em&gt;single implementation in the package&lt;/em&gt;, because unit tests can just provide a “dummy” implementation and test related code that way. An example of this is the code for &lt;a href=&#34;https://github.com/tpapp/DynamicHMC.jl/blob/4c0d616ebaa4cec900d5f023376f08f204feb020/src/trees.jl&#34;&gt;“trees”&lt;/a&gt; and the &lt;a href=&#34;https://github.com/tpapp/DynamicHMC.jl/blob/4c0d616ebaa4cec900d5f023376f08f204feb020/test/test-trees.jl&#34;&gt;related tests&lt;/a&gt;: trees here are an abstraction for walking &lt;em&gt;integer positions&lt;/em&gt; in two directions. This is key for the NUTS algorithm, but can be handled as an abstraction separate from the details of leapfrog integrators.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Setting up Julia with continuous integration on Gitlab</title>
    <link href="https://tamaspapp.eu/post/julia-ci-gitlab/"/>
    <id>https://tamaspapp.eu/post/julia-ci-gitlab/</id>
    <published>2018-03-08T17:06:54+01:00</published>
    <updated>2018-03-08T17:06:54+01:00</updated>
    
    <content type="html" xml:base="https://tamaspapp.eu/post/julia-ci-gitlab/">&lt;p&gt;As an academic, I picked up good practices for programming mostly by osmosis. My approach to “testing” software went through the following stages:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;See if the code runs (this got me through my undergrad years).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check if the results “look OK”, then forget about testing.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Compare results occasionally to known results from papers or other code (eg in a different language).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Write some unit tests &lt;em&gt;ex post&lt;/em&gt;, as an afterthought after the code is finished (time pressure helps to ensure that overtesting is never a problem).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use unit tests from the very beginning, especially before optimizing and refactoring code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set up automatic testing, as part of &lt;em&gt;continuous integration&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I think that 1–3 above is a pretty usual path, naturally traversed after the recognition that &lt;em&gt;some&lt;/em&gt; testing would be nice, but lacking the knowledge of &lt;em&gt;how to implement it&lt;/em&gt; in a consistent manner. This is comparable to using copies of directories as crude attempts at “version control”.&lt;/p&gt;

&lt;p&gt;Later, I picked up 4–6 while being exposed to these ideas when learning about new languages. Automated unit testing is one of those things one does not miss until learning about it, then subsequently cannot imagine doing without. In a research context, the two main advantages are &lt;em&gt;scientific integrity&lt;/em&gt; — I should make a best effort to ensure that my results are correct — and &lt;em&gt;dealing with bugs early&lt;/em&gt;. While the first one is abstract and philosophical, the second is a practical concern: I found that if I skimp on testing, the bugs show up much later, usually at an inconvenient time, and I will have to spent time locating the bug (not always trivial, especially with numerical code) and switch context to something I was working on months ago. It is my experience that while tests can be tedious to write, time spent on them is a very good investment.&lt;/p&gt;

&lt;p&gt;I knew about unit tests before coming to Julia, but learned about automated CI in the Julia community. This was because package template libraries “do the right thing” by making it very easy to set up an automated testing framework: for example, &lt;code&gt;PkgDev.generate&lt;/code&gt; creates the appropriate test configuration for &lt;a href=&#34;http://travis-ci.org/&#34;&gt;Travis CI&lt;/a&gt; and various coverage services.&lt;/p&gt;

&lt;p&gt;I never cease to be amazed by the fact that these services are available for free for public / open source projects, which is very generous of these providers. However, occasionally one would like to keep the project private for a little while. The usual scenario for me is working on code that is related to a paper, which I plan to make public with the latter; in this case one would need the pro (non-free) version of Travis and related tools.&lt;/p&gt;

&lt;p&gt;Alternatively, &lt;a href=&#34;https://gitlab.com/&#34;&gt;Gitlab&lt;/a&gt; offers CI/CD with private repositories. I am exploring this at the moment for various projects, and boiled down the necessary configuration into the repository &lt;a href=&#34;https://gitlab.com/tkpapp/GitlabJuliaDemo.jl&#34;&gt;GitlabJuliaDemo.jl&lt;/a&gt;. It has&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;a CI setup for &lt;code&gt;Pkg.test&lt;/code&gt;,&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;a coverage &lt;em&gt;summary&lt;/em&gt; as a percentage.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;While coverage analysis could be &lt;a href=&#34;https://about.gitlab.com/2016/11/03/publish-code-coverage-report-with-gitlab-pages/&#34;&gt;automated&lt;/a&gt; too with a custom Docker image, I leave his for future work.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:In-the-next-post&#34;&gt;&lt;a class=&#34;footnote&#34; href=&#34;#fn:In-the-next-post&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;So far, I am very satisfied with Gitlab. The interface is well-designed, clean, and intuitive; tests complete in a few minutes (just like Travis).&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:In-the-next-post&#34;&gt;In the next post I will talk about local coverage analysis in Julia. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:In-the-next-post&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Continuous integration for Julia packages using Docker</title>
    <link href="https://tamaspapp.eu/post/travis-docker-julia-ci/"/>
    <id>https://tamaspapp.eu/post/travis-docker-julia-ci/</id>
    <published>2018-01-19T08:47:06+01:00</published>
    <updated>2018-01-19T08:47:06+01:00</updated>
    
    <content type="html" xml:base="https://tamaspapp.eu/post/travis-docker-julia-ci/">&lt;p&gt;This post may be useful for maintainers of Julia packages which require a large binary dependencies on CI services like Travis.&lt;/p&gt;

&lt;p&gt;I have recently started using Kristoffer Carlsson&#39;s excellent &lt;a href=&#34;https://github.com/KristofferC/PGFPlotsX.jl&#34;&gt;PGFPlotsX&lt;/a&gt; for plotting. The package is a thin wrapper which emits LaTeX code for use with &lt;a href=&#34;http://pgfplots.sourceforge.net/&#34;&gt;pgfplots&lt;/a&gt;, which is extremely versatile and well-documented.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Using-this-packa&#34;&gt;&lt;a class=&#34;footnote&#34; href=&#34;#fn:Using-this-packa&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; However, since most of the action happens in LaTeX, unit testing requires a lot of binary dependencies, including the &lt;a href=&#34;https://tug.org/texlive/&#34;&gt;TeXLive&lt;/a&gt; suite and some related packages. This is not a problem on one&#39;s own machine where these would need to be installed just once, but when I submitted PRs, tests on Travis timed out more often than not because it had to install all of these for every run using &lt;code&gt;apt-get&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The documentation of Travis suggested that &lt;a href=&#34;http://docker.com/&#34;&gt;docker&lt;/a&gt; may be a solution for such cases, and I have been looking an opportunity to experiment with it anyway. After reading their tutorial it was relatively quick to produce an image based on plain vanilla Ubuntu 17.10, which is available as a docker image to build on, and the required TeXLive and related packages, plus some utilities.&lt;/p&gt;

&lt;p&gt;During building the image, I download the binaries for the stable version Julia, while &lt;code&gt;nightly&lt;/code&gt; is downloaded on demand. This speeds up CI by 40–50 seconds for &lt;code&gt;stable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is how it is run:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;the directory of the Julia package is mounted in the container at &lt;code&gt;/mnt&lt;/code&gt;,&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Pkg.clone()&lt;/code&gt; and testing proceed as usual,&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;coverage results are copied back to &lt;code&gt;/mnt&lt;/code&gt; when done.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The resulting image runs in 3–4 minutes consistently. In case someone finds it useful for Julia packages with similarly large binary dependencies, I made it available as &lt;a href=&#34;https://github.com/tpapp/texlive-julia-minimal-docker&#34;&gt;&lt;code&gt;texlive-julia-minimal-docker&lt;/code&gt;&lt;/a&gt; on Github.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Minimal-turns-ou&#34;&gt;&lt;a class=&#34;footnote&#34; href=&#34;#fn:Minimal-turns-ou&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; Naturally, for projects with other large binary dependencies, one would install different Ubuntu packages or binaries.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:Using-this-packa&#34;&gt;Using this package accelerated my plotting workflow in Julia. A post on this will follow soon. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Using-this-packa&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:Minimal-turns-ou&#34;&gt;“Minimal” turns out to be a misnomer, since some dependencies end up requiring X11 and the image is &amp;gt;700GB. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Minimal-turns-ou&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  
</feed>
