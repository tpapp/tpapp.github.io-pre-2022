<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Numerical erroronTamás K. Papp&#39;s website</title>
  <link href="https://tpapp.github.io/index.xml" rel="self"/>
  <link href="https://tpapp.github.io/tags/numerical-error/"/>
  <updated>2017-09-13T11:18:59+02:00</updated>
  
  <id>https://tpapp.github.io/tags/numerical-error/</id>
  <author>
    <name>Tamás K. Papp</name>
  </author>
  <generator>Hugo -- gohugo.io</generator>
  
  <entry>
    <title type="html">log1p in Julia</title>
    <link href="https://tpapp.github.io/post/log1p/"/>
    <id>https://tpapp.github.io/post/log1p/</id>
    <published>2017-09-13T11:18:59+02:00</published>
    <updated>2017-09-13T11:18:59+02:00</updated>
    
    <content type="html" xml:base="https://tpapp.github.io/post/log1p/">

&lt;p&gt;&lt;em&gt;edit&lt;/em&gt;: fixed bogus interaction of MathJax and code highlighting.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;edit2&lt;/em&gt;: added benchmarks.&lt;/p&gt;

&lt;p&gt;This is a follow-up on a &lt;a href=&#34;https://discourse.julialang.org/t/log1p-in-base-vs-base-math-julialibm/5852&#34;&gt;question&lt;/a&gt; I asked on the Julia forums about calculating
[
\text{log1p}(x) = \log(1+x)
]
This calculation is tricky because if $x \approx 0$,
[
\log(1+x) \approx x
]
while as $x \to \infty$, $\log(1+x)$ approaches $\log(x)$, so simply using &lt;code&gt;log(1+x)&lt;/code&gt; will not be as accurate as it could be. Numerical analysts have developed specialized methods for these calculations that try to get an accurate answer, and all programming languages serious about numerical calculations have an implementation either in the core language or a library.&lt;/p&gt;

&lt;p&gt;Julia&amp;rsquo;s &lt;code&gt;Base.log1p&lt;/code&gt; currently suggests that &lt;code&gt;Base.Math.JuliaLibm.log1p&lt;/code&gt; would be preferable, but then I was wondering why isn&amp;rsquo;t that the default? So I decided to perform a trivial numerical experiment, calculating the error for both, and also benchmark the two methods.&lt;/p&gt;

&lt;h2 id=&#34;accuracy&#34;&gt;Accuracy&lt;/h2&gt;

&lt;p&gt;The key question is what to compare the results with. One could compare to an existing &amp;ldquo;gold standard&amp;rdquo; implementation, or simply calculate the results using a higher precision representation. Fortunately, Julia has &lt;code&gt;BigFloat&lt;/code&gt;s available right out of the box.&lt;/p&gt;

&lt;p&gt;The graph below shows the base-2 logarithm of the &lt;em&gt;relative&lt;/em&gt; error for &lt;code&gt;Base.log1p&lt;/code&gt; vs $\log_2(1+x)$; horizontal lines are &lt;code&gt;log2(eps())&lt;/code&gt; and &lt;code&gt;log2(eps())+1&lt;/code&gt;. This suggests that &lt;code&gt;Base.log1p&lt;/code&gt; is &lt;em&gt;very accurate&lt;/em&gt;, but not as good as it could be when $x \approx 0$.&lt;/p&gt;



&lt;img src=&#34;https://tpapp.github.io/post/log1p/Base_log1p_error.svg&#34; alt=&#34;Base.log1p error&#34;&gt;


&lt;p&gt;The next plot shows the relative accuracy of the relative error above, comparing &lt;code&gt;Base.Math.JuliaLibm.log1p&lt;/code&gt; to &lt;code&gt;Base.log1p&lt;/code&gt; (lower values better). In these simulations, &lt;code&gt;Base.Math.JuliaLibm.log1p&lt;/code&gt; is never worse, but sometimes significantly better (resulting in an extra binary digit of accuracy). This matters especially when $x \approx 0$.&lt;/p&gt;



&lt;img src=&#34;https://tpapp.github.io/post/log1p/JuliaLibm_improvement.svg&#34; alt=&#34;relative log2 acccuracy improvement over Base.log1p&#34;&gt;


&lt;p&gt;The next plot confirms this.&lt;/p&gt;



&lt;img src=&#34;https://tpapp.github.io/post/log1p/JuliaLibm_log1p_error.svg&#34; alt=&#34;JuliaLibm log1p error&#34;&gt;


&lt;h2 id=&#34;speed&#34;&gt;Speed&lt;/h2&gt;

&lt;p&gt;I also evaluated relative speed. The graph below shows the relative runtimes, obtained using &lt;code&gt;BenchmarkTools.@belapsed&lt;/code&gt;. Values below $1$ mean that &lt;code&gt;Base.Math.JuliaLibm.log1p&lt;/code&gt; is faster: indeed, this seems to be the case except for values very close to $0$, where there is a 10&amp;ndash;20% performance penalty. At other values, &lt;code&gt;Base.Math.JuliaLibm.log1p&lt;/code&gt; is 30&amp;ndash;40% &lt;em&gt;faster&lt;/em&gt;.&lt;/p&gt;



&lt;img src=&#34;https://tpapp.github.io/post/log1p/relative_time.svg&#34; alt=&#34;relative time&#34;&gt;


&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;For values near $0$, &lt;code&gt;Base.Math.JuliaLibm.log1p&lt;/code&gt; is more accurate, at a slight performance cost.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For values away from $0$, it is at least as accurate as &lt;code&gt;Base.log1p&lt;/code&gt;, and 30&amp;ndash;40% faster.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To me, this suggests that &lt;code&gt;Base.Math.JuliaLibm.log1p&lt;/code&gt; should be the default method &amp;mdash; mostly because the extra accuracy is more important to me than the slight performance cost.&lt;/p&gt;

&lt;p&gt;Code is available below.&lt;/p&gt;




&lt;div class=&#34;codeheader&#34;&gt;&lt;p&gt;download as &lt;a href=&#34;https://tpapp.github.io/post/log1p/code.jl&#34;&gt;code.jl&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span class=&#34;s1770&#34;&gt;# consistent random numbers&lt;/span&gt;
srand(&lt;span class=&#34;s3ee&#34;&gt;UInt32&lt;/span&gt;[&lt;span class=&#34;sc83&#34;&gt;0xfd909253&lt;/span&gt;, &lt;span class=&#34;sc83&#34;&gt;0x7859c364&lt;/span&gt;, &lt;span class=&#34;sc83&#34;&gt;0x7cd42419&lt;/span&gt;, &lt;span class=&#34;sc83&#34;&gt;0x4c06a3b6&lt;/span&gt;])

&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;    err(x, [prec])
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;Return two values, which are the log2 relative errors for calculating
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;`log1p(x)`, using `Base.log1p` and `Base.Math.JuliaLibm.log1p`.
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;The errors are calculated by compating to `BigFloat` calculations with the given
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;precision `prec`.
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;span class=&#34;s3e8&#34;&gt;function&lt;/span&gt; err(x, prec &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc84&#34;&gt;1024&lt;/span&gt;)
    yb &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; log(&lt;span class=&#34;sc84&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;sfa0&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;s3ee&#34;&gt;BigFloat&lt;/span&gt;(x, prec))
    e2(y) &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s3ee&#34;&gt;Float64&lt;/span&gt;(log2(abs(y&lt;span class=&#34;sfa0&#34;&gt;-&lt;/span&gt;yb)&lt;span class=&#34;sfa0&#34;&gt;/&lt;/span&gt;abs(yb)))
    e2(log1p(x)), e2(Base&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;Math&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;JuliaLibm&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;log1p(x))
&lt;span class=&#34;s3e8&#34;&gt;end&lt;/span&gt;

z &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; exp&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;(randn(&lt;span class=&#34;sc84&#34;&gt;20000&lt;/span&gt;)&lt;span class=&#34;sfa0&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;sc84&#34;&gt;10&lt;/span&gt;)       &lt;span class=&#34;s1770&#34;&gt;# z &amp;gt; 0, Lognormal(0, 10)&lt;/span&gt;
x &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; z &lt;span class=&#34;sfa0&#34;&gt;.-&lt;/span&gt; &lt;span class=&#34;sc84&#34;&gt;1&lt;/span&gt;                      &lt;span class=&#34;s1770&#34;&gt;# x &amp;gt; -1&lt;/span&gt;
es &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; map(err, x)                &lt;span class=&#34;s1770&#34;&gt;# errors&lt;/span&gt;

&lt;span class=&#34;s3e8&#34;&gt;using&lt;/span&gt; Plots; gr()               &lt;span class=&#34;s1770&#34;&gt;# plots&lt;/span&gt;

scatter(log2&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;(z), first&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;(es), xlab &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;log2(x+1)&amp;#34;&lt;/span&gt;, ylab &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;log2 error of Base.log1p&amp;#34;&lt;/span&gt;,
        legend &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s3e8&#34;&gt;false&lt;/span&gt;)
hline!(log2(eps())&lt;span class=&#34;sfa0&#34;&gt;-&lt;/span&gt;[&lt;span class=&#34;sc84&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;sc84&#34;&gt;1&lt;/span&gt;])
Plots&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;svg(&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;Base_log1p_error.svg&amp;#34;&lt;/span&gt;)
scatter(log2&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;(z), last&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;(es) &lt;span class=&#34;sfa0&#34;&gt;.-&lt;/span&gt; first&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;(es), xlab &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;log2(x+1)&amp;#34;&lt;/span&gt;,
        ylab &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;improvement (Base.Math.JuliaLibm.log1p)&amp;#34;&lt;/span&gt;, legend &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s3e8&#34;&gt;false&lt;/span&gt;)
Plots&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;svg(&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;JuliaLibm_improvement.svg&amp;#34;&lt;/span&gt;)
scatter(log2&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;(z), last&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;(es), xlab &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;log2(x+1)&amp;#34;&lt;/span&gt;,
        ylab &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;log2 error of Base.Math.JuliaLibm.log1p&amp;#34;&lt;/span&gt;, legend &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s3e8&#34;&gt;false&lt;/span&gt;)
hline!(log2(eps())&lt;span class=&#34;sfa0&#34;&gt;-&lt;/span&gt;[&lt;span class=&#34;sc84&#34;&gt;0&lt;/span&gt;,&lt;span class=&#34;sc84&#34;&gt;1&lt;/span&gt;])
Plots&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;svg(&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;JuliaLibm_log1p_error.svg&amp;#34;&lt;/span&gt;)

&lt;span class=&#34;s1770&#34;&gt;######################################################################&lt;/span&gt;
&lt;span class=&#34;s1770&#34;&gt;# WARNING: these run for a very long time&lt;/span&gt;
&lt;span class=&#34;s1770&#34;&gt;######################################################################&lt;/span&gt;
&lt;span class=&#34;s3e8&#34;&gt;using&lt;/span&gt; BenchmarkTools

z &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; exp&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;(vcat(randn(&lt;span class=&#34;sc84&#34;&gt;200&lt;/span&gt;)&lt;span class=&#34;sfa0&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;sc84&#34;&gt;10&lt;/span&gt;, rand(&lt;span class=&#34;sc84&#34;&gt;200&lt;/span&gt;)&lt;span class=&#34;sfa0&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;sc82&#34;&gt;0.1&lt;/span&gt;)) &lt;span class=&#34;s1770&#34;&gt;# z &amp;gt; 0, more values around &lt;/span&gt;
x &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; z &lt;span class=&#34;sfa0&#34;&gt;.-&lt;/span&gt; &lt;span class=&#34;sc84&#34;&gt;1&lt;/span&gt;                                   &lt;span class=&#34;s1770&#34;&gt;# x &amp;gt; -1&lt;/span&gt;
b1 &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; [&lt;span class=&#34;s7d6&#34;&gt;@belapsed&lt;/span&gt; log1p(&lt;span class=&#34;sfa0&#34;&gt;$&lt;/span&gt;x) &lt;span class=&#34;s3e8&#34;&gt;for&lt;/span&gt; x &lt;span class=&#34;s3ec&#34;&gt;in&lt;/span&gt; x]        &lt;span class=&#34;s1770&#34;&gt;# WARNING: takes forever&lt;/span&gt;
b2 &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; [&lt;span class=&#34;s7d6&#34;&gt;@belapsed&lt;/span&gt; Base&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;Math&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;JuliaLibm&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;log1p(&lt;span class=&#34;sfa0&#34;&gt;$&lt;/span&gt;x) &lt;span class=&#34;s3e8&#34;&gt;for&lt;/span&gt; x &lt;span class=&#34;s3ec&#34;&gt;in&lt;/span&gt; x] &lt;span class=&#34;s1770&#34;&gt;# ditto&lt;/span&gt;

scatter(log2&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;(z), b2 &lt;span class=&#34;sfa0&#34;&gt;./&lt;/span&gt; b1, xlab &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;log2(x+1)&amp;#34;&lt;/span&gt;,
        ylab &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;time Math.JuliaLibm.log1p / log1p&amp;#34;&lt;/span&gt;, legend &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s3e8&#34;&gt;false&lt;/span&gt;, yticks &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc84&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;sfa0&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;sc82&#34;&gt;0.2&lt;/span&gt;&lt;span class=&#34;sfa0&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;sc82&#34;&gt;1.2&lt;/span&gt;)
hline!([&lt;span class=&#34;sc84&#34;&gt;1&lt;/span&gt;])
Plots&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;svg(&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;relative_time.svg&amp;#34;&lt;/span&gt;)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
  </entry>
  
</feed>
