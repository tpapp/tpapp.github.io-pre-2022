<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MicrooptimizationonTamás K. Papp&#39;s website</title>
  <link href="https://tpapp.github.io/index.xml" rel="self"/>
  <link href="https://tpapp.github.io/tags/microoptimization/"/>
  <updated>2017-10-03T11:40:58+02:00</updated>
  
  <id>https://tpapp.github.io/tags/microoptimization/</id>
  <author>
    <name>Tamás K. Papp</name>
  </author>
  <generator>Hugo -- gohugo.io</generator>
  
  <entry>
    <title type="html">CPU pipelines: when more is less</title>
    <link href="https://tpapp.github.io/post/branch_prediction/"/>
    <id>https://tpapp.github.io/post/branch_prediction/</id>
    <published>2017-10-03T11:40:58+02:00</published>
    <updated>2017-10-03T11:40:58+02:00</updated>
    
    <content type="html" xml:base="https://tpapp.github.io/post/branch_prediction/">&lt;p&gt;I have been working on micro-optimizations for some simulation
code, and was reminded of a counter-intuitive artifact of modern CPU
architecture, which is worth a short post.&lt;/p&gt;

&lt;p&gt;Consider (just for the sake of example) a very simple (if not
particularly meaningful) function,&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[
f(x) = \begin{cases}
(x+2)^2 &amp; \text{if } x \ge 0,\\
1-x &amp; \text{otherwise}
\end{cases}
\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;with implementations&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;f1(x) &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; ifelse(x &lt;span class=&#34;sfa0&#34;&gt;≥&lt;/span&gt; &lt;span class=&#34;sc84&#34;&gt;0&lt;/span&gt;, abs2(x&lt;span class=&#34;sfa0&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;sc84&#34;&gt;2&lt;/span&gt;), &lt;span class=&#34;sc84&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;sfa0&#34;&gt;-&lt;/span&gt;x)
f2(x) &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; x &lt;span class=&#34;sfa0&#34;&gt;≥&lt;/span&gt; &lt;span class=&#34;sc84&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;sfa0&#34;&gt;?&lt;/span&gt; abs2(x&lt;span class=&#34;sfa0&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;sc84&#34;&gt;2&lt;/span&gt;) &lt;span class=&#34;sfa0&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sc84&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;sfa0&#34;&gt;-&lt;/span&gt;x&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;f1&lt;/code&gt; calculates &lt;em&gt;both&lt;/em&gt; possibilities before choosing between them with
&lt;code&gt;ifelse&lt;/code&gt;, while &lt;code&gt;f2&lt;/code&gt; will only calculate values on demand. So, intuitively, it should be faster.&lt;/p&gt;

&lt;p&gt;But it isn&#39;t...&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span class=&#34;sfa0&#34;&gt;&amp;gt;&lt;/span&gt; x &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; randn(&lt;span class=&#34;sc84&#34;&gt;1_000_000&lt;/span&gt;);

julia&lt;span class=&#34;sfa0&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;s3e8&#34;&gt;using&lt;/span&gt; BenchmarkTools

julia&lt;span class=&#34;sfa0&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;s7d6&#34;&gt;@btime&lt;/span&gt; f1&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;(&lt;span class=&#34;sfa0&#34;&gt;$&lt;/span&gt;x);
  &lt;span class=&#34;sc82&#34;&gt;664.228&lt;/span&gt; μs (&lt;span class=&#34;sc84&#34;&gt;2&lt;/span&gt; allocations&lt;span class=&#34;sfa0&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sc82&#34;&gt;7.63&lt;/span&gt; MiB)

julia&lt;span class=&#34;sfa0&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;s7d6&#34;&gt;@btime&lt;/span&gt; f2&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;(&lt;span class=&#34;sfa0&#34;&gt;$&lt;/span&gt;x);
  &lt;span class=&#34;sc82&#34;&gt;6.519&lt;/span&gt; ms (&lt;span class=&#34;sc84&#34;&gt;2&lt;/span&gt; allocations&lt;span class=&#34;sfa0&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sc82&#34;&gt;7.63&lt;/span&gt; MiB)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;...it is about 10x &lt;em&gt;slower&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This can be understood as an artifact of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Instruction_pipelining&#34;&gt;instruction
pipeline&lt;/a&gt;: your
x86 CPU likes to perform similar operations in staggered manner, and
it does not like branches (jumps) because they break the flow.&lt;/p&gt;

&lt;p&gt;Comparing the native code reveals that while &lt;code&gt;f1&lt;/code&gt; is jump-free, the &lt;code&gt;if&lt;/code&gt; in &lt;code&gt;f2&lt;/code&gt; results in a jump (&lt;code&gt;jae&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;julia&lt;span class=&#34;sfa0&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;s7d6&#34;&gt;@code_native&lt;/span&gt; f1(&lt;span class=&#34;sc82&#34;&gt;1.0&lt;/span&gt;)
        &lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;text
Filename&lt;span class=&#34;sfa0&#34;&gt;:&lt;/span&gt; REPL[&lt;span class=&#34;sc84&#34;&gt;2&lt;/span&gt;]
        pushq   &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rbp
        movq    &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rsp, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rbp
        movabsq &lt;span class=&#34;sfa0&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;sc84&#34;&gt;139862498743472&lt;/span&gt;, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rax  &lt;span class=&#34;s1770&#34;&gt;# imm = 0x7F34468E14B0&lt;/span&gt;
        movsd   (&lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rax), &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm2           &lt;span class=&#34;s1770&#34;&gt;# xmm2 = mem[0],zero&lt;/span&gt;
Source line&lt;span class=&#34;sfa0&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sc84&#34;&gt;1&lt;/span&gt;
        addsd   &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm0, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm2
        mulsd   &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm2, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm2
        movabsq &lt;span class=&#34;sfa0&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;sc84&#34;&gt;139862498743480&lt;/span&gt;, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rax  &lt;span class=&#34;s1770&#34;&gt;# imm = 0x7F34468E14B8&lt;/span&gt;
        movsd   (&lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rax), &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm3           &lt;span class=&#34;s1770&#34;&gt;# xmm3 = mem[0],zero&lt;/span&gt;
        subsd   &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm0, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm3
        xorps   &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm1, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm1
        cmpnlesd        &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm0, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm1
        andpd   &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm1, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm3
        andnpd  &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm2, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm1
        orpd    &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm3, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm1
        movapd  &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm1, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm0
        popq    &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rbp
        retq
        nopw    &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;cs&lt;span class=&#34;sfa0&#34;&gt;:&lt;/span&gt;(&lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rax,&lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rax)

julia&lt;span class=&#34;sfa0&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;s7d6&#34;&gt;@code_native&lt;/span&gt; f2(&lt;span class=&#34;sc82&#34;&gt;1.0&lt;/span&gt;)
        &lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;text
Filename&lt;span class=&#34;sfa0&#34;&gt;:&lt;/span&gt; REPL[&lt;span class=&#34;sc84&#34;&gt;3&lt;/span&gt;]
        pushq   &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rbp
        movq    &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rsp, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rbp
Source line&lt;span class=&#34;sfa0&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sc84&#34;&gt;1&lt;/span&gt;
        xorps   &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm1, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm1
        ucomisd &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm1, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm0
        jae     L37
        movabsq &lt;span class=&#34;sfa0&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;sc84&#34;&gt;139862498680736&lt;/span&gt;, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rax  &lt;span class=&#34;s1770&#34;&gt;# imm = 0x7F34468D1FA0&lt;/span&gt;
        movsd   (&lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rax), &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm1           &lt;span class=&#34;s1770&#34;&gt;# xmm1 = mem[0],zero&lt;/span&gt;
        subsd   &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm0, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm1
        movapd  &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm1, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm0
        popq    &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rbp
        retq
L37&lt;span class=&#34;sfa0&#34;&gt;:&lt;/span&gt;
        movabsq &lt;span class=&#34;sfa0&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;sc84&#34;&gt;139862498680728&lt;/span&gt;, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rax  &lt;span class=&#34;s1770&#34;&gt;# imm = 0x7F34468D1F98&lt;/span&gt;
        addsd   (&lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rax), &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm0
        mulsd   &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm0, &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;xmm0
        popq    &lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rbp
        retq
        nopl    (&lt;span class=&#34;sfa0&#34;&gt;%&lt;/span&gt;rax)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;In my application the speed gain was more modest, but still
sizeable. Benchmarking a non-branching version of your code is
sometimes worth it, especially if it the change is simple &lt;em&gt;and&lt;/em&gt; both
branches of the conditional can be run error-free. If, for example, we
had to calculate&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;g(x) &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; x &lt;span class=&#34;sfa0&#34;&gt;≥&lt;/span&gt; &lt;span class=&#34;sc84&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;sfa0&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;sfa0&#34;&gt;√&lt;/span&gt;(x&lt;span class=&#34;sfa0&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;sc84&#34;&gt;2&lt;/span&gt;) &lt;span class=&#34;sfa0&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sc84&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;sfa0&#34;&gt;-&lt;/span&gt;x&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;then we could not use &lt;code&gt;ifelse&lt;/code&gt; without restricting the domain, since
&lt;code&gt;√(x+2)&lt;/code&gt; would fail whenever &lt;code&gt;x &amp;lt; -2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Julia &lt;code&gt;Base&lt;/code&gt; contains many optimizations like this: for a particularly
nice example see functions that use &lt;code&gt;Base.null_safe_op&lt;/code&gt;.&lt;/p&gt;
</content>
  </entry>
  
</feed>
