<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Packages on Tamás K. Papp&#39;s website</title>
  <link href="https://tpapp.github.io/index.xml" rel="self"/>
  <link href="https://tpapp.github.io/tags/packages/"/>
  <updated>2017-10-15T13:02:14+02:00</updated>
  
  <id>https://tpapp.github.io/tags/packages/</id>
  <author>
    <name>Tamás K. Papp</name>
  </author>
  <generator>Hugo -- gohugo.io</generator>
  
  <entry>
    <title type="html">Clarification: on orphaning my Common Lisp libraries</title>
    <link href="https://tpapp.github.io/post/orphaned-lisp-libraries/"/>
    <id>https://tpapp.github.io/post/orphaned-lisp-libraries/</id>
    <published>2017-10-15T13:02:14+02:00</published>
    <updated>2017-10-15T13:02:14+02:00</updated>
    
    <content type="html" xml:base="https://tpapp.github.io/post/orphaned-lisp-libraries/">&lt;p&gt;I have not been programming in Common Lisp for a few years, and since
I find &lt;a href=&#34;https://julialang.org/&#34;&gt;Julia&lt;/a&gt; a &amp;quot;much better Lisp&amp;quot;, I am
unlikely to go back to it in the foreseeable future. This is a
clarification regarding some
&lt;a href=&#34;https://github.com/tpapp?utf8=%E2%9C%93&amp;amp;tab=repositories&amp;amp;q=&amp;amp;type=public&amp;amp;language=common%20lisp&#34;&gt;libraries&lt;/a&gt;
I have written in Common Lisp and made public.&lt;/p&gt;

&lt;h1 id=&#34;all-of-my-common-lisp-libraries-are-orphaned&#34;&gt;All of my Common Lisp libraries are orphaned&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;They are effectively &lt;em&gt;abandonware&lt;/em&gt; as far as I am concerned. Since
fixing issues and evaluating PRs entails a large fixed cost for
which I don&#39;t have the time (setting up my CL environment again,
understanding what I wrote years ago, thinking about code
correctness and corner cases of the language spec that I have
forgotten), I will ignore issues and pull requests. Sorry about this.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you find anything of value in these libraries, please feel free
to use that according to their licenses. &lt;em&gt;You don&#39;t have to ask me
explicitly.&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you want to take over maintaining any of these libraries, &lt;em&gt;you
don&#39;t have to ask me&lt;/em&gt;. &lt;strong&gt;Just fork, and start coding.&lt;/strong&gt; If you have
been consistently maintaining one of these libraries for a year or
more, announce that you are resurrecting the library on the
relevant Common Lisp forums. You can also drop me an e-mail and I
will put a line in the README of my version that redirects users to
your version. Eventually, you should convince &lt;a href=&#34;https://github.com/quicklisp/&#34;&gt;Zach
Beane&lt;/a&gt; to use your version in
Quicklisp.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I cannot provide any significant help regarding the code
due to time constraints. Some of it is documented, and most of it
has unit tests, you have to figure out the rest yourself.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;which-libraries-are-worth-the-effort&#34;&gt;Which libraries are worth the effort?&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;let-plus&lt;/code&gt; is an extensible destructuring library. The syntax is
versatile and intuitive.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;LLA&lt;/code&gt;, aka Lisp Linear Algebra, is a wrapper for BLAS/LAPACK using
native Common Lisp arrays. It is somewhat incomplete (eigenvalues
need some work) but what is available works. It is &lt;em&gt;fast&lt;/em&gt; on
implementations which provide arrays for certain float element
types, so that it does not have to copy the data, and is a bit
slower on implementations that don&#39;t allow this. Still, copying is
&lt;span  class=&#34;math&#34;&gt;\(O(n)\)&lt;/span&gt;, while most LAPACK operations are &lt;span  class=&#34;math&#34;&gt;\(O(n^2)\)&lt;/span&gt; or worse, so
this is not a huge concern. Nevertheless, it is possible that
implementations that did not provide specialized arrays at the time
I wrote LLA have caught up. You would need to extend the glue code
to work with them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;cl-slice&lt;/code&gt;, array slices for native Common Lisp arrays.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;cl-random&lt;/code&gt;, &lt;code&gt;cl-num-utils&lt;/code&gt;, &lt;code&gt;cl-rmath&lt;/code&gt;: random numbers, simple
numerical algorithms, a wrapper for libRmath.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;cl-colors&lt;/code&gt;, named colors and color combinations.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The rest are either early experiments, preliminary versions that
evolved into the libraries above, or projects that did not pan out.&lt;/p&gt;

&lt;p&gt;PS.: Some people asked why I switched to Julia from Common Lisp. A
post about that will follow soon.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Local packages in a separate directory in Julia</title>
    <link href="https://tpapp.github.io/post/julia-local-test/"/>
    <id>https://tpapp.github.io/post/julia-local-test/</id>
    <published>2017-08-23T10:10:48+02:00</published>
    <updated>2017-08-23T10:10:48+02:00</updated>
    
    <content type="html" xml:base="https://tpapp.github.io/post/julia-local-test/">&lt;p&gt;I run &lt;code&gt;Pkg.update()&lt;/code&gt; fairly often to stay up to date and benefit from
the latest improvements of various packages. I rarely ever &lt;code&gt;pin&lt;/code&gt; to a
specific package version, but I occasionally checkout &lt;code&gt;master&lt;/code&gt; for
some packages, especially if I am contributing.&lt;/p&gt;

&lt;p&gt;Despite updating regularly, I found that the documentation subtly diverged from what I was experiencing for some packages. After looking into the issue, I learned that I was 2&amp;ndash;3 minor versions behind despite updating regularly. For example, when I would&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;Pkg&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;update(&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;ForwardDiff&amp;#34;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;I would be told that there is a new version, and to get it I should update &lt;code&gt;ReverseDiff&lt;/code&gt; and &lt;code&gt;Optim&lt;/code&gt;. But&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;Pkg&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;update(&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;ForwardDiff&amp;#34;&lt;/span&gt;, &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;ReverseDiff&amp;#34;&lt;/span&gt;, &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;Optim&amp;#34;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;would just run quietly without updating.&lt;/p&gt;

&lt;p&gt;I could not figure out the cause for this and did not want to get sidetracked debugging it, so I decided to wipe the package directory and start over. However, in order to do this, I had to make sure that no code is lost, especially for local packages. First, I moved my local packages into a separate directory, and added that to &lt;code&gt;LOAD_PATH&lt;/code&gt; in &lt;code&gt;.juliarc.jl&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;push!(&lt;span class=&#34;s7d2&#34;&gt;LOAD_PATH&lt;/span&gt;, expanduser(&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;~/src/julia-local-packages/&amp;#34;&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Then I ran &lt;a href=&#34;https://github.com/fboender/multi-git-status&#34;&gt;multi-git-status&lt;/a&gt; to make sure that there were no unpushed changes. Finally, I deleted the package directory and reinstalled everything. Surprisingly, &lt;code&gt;Pkg.add&lt;/code&gt; ran much faster than before.&lt;/p&gt;

&lt;p&gt;In case I have to do this again, I decided to keep my local packages separate &amp;mdash; the only drawback is that &lt;code&gt;Pkg.test&lt;/code&gt; now can&amp;rsquo;t find them. A workaround is below, using some code from &lt;code&gt;Base.Pkg&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;    local_test(pkgname, [coverage])
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;Find and test a package in `LOAD_PATH`. Useful when the package is outside
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;`Pkg.dir()`.
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;Assumes the usual directory structure: package has the same name as the module,
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;the main file is in `src/Pkgname.jl`, while tests are in `test/runtests.jl`.
&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;span class=&#34;s3e8&#34;&gt;function&lt;/span&gt; local_test(pkgname; coverage&lt;span class=&#34;sfa0&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;s3ee&#34;&gt;Bool&lt;/span&gt;&lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s3e8&#34;&gt;false&lt;/span&gt;)
    module_path &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; Base&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;find_in_path(pkgname, &lt;span class=&#34;s7d2&#34;&gt;nothing&lt;/span&gt;)
    src_dir, module_file &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; splitdir(module_path)
    dir &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; normpath(src_dir, &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;..&amp;#34;&lt;/span&gt;)
    test_path &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; joinpath(dir, &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;test&amp;#34;&lt;/span&gt;, &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;runtests.jl&amp;#34;&lt;/span&gt;)
    &lt;span class=&#34;s7d6&#34;&gt;@assert&lt;/span&gt; isfile(test_path) &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;Could not find &lt;/span&gt;&lt;span class=&#34;sc27&#34;&gt;$&lt;/span&gt;(test_path)&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;&lt;/span&gt;
    Base&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;cd(dir) &lt;span class=&#34;s3e8&#34;&gt;do&lt;/span&gt;
        &lt;span class=&#34;s3e8&#34;&gt;try&lt;/span&gt;
            color &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; Base&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;have_color&lt;span class=&#34;sfa0&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;--color=yes&amp;#34;&lt;/span&gt; &lt;span class=&#34;sfa0&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;--color=no&amp;#34;&lt;/span&gt;
            codecov &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; coverage&lt;span class=&#34;sfa0&#34;&gt;?&lt;/span&gt; [&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;--code-coverage=user&amp;#34;&lt;/span&gt;] &lt;span class=&#34;sfa0&#34;&gt;:&lt;/span&gt; [&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;--code-coverage=none&amp;#34;&lt;/span&gt;]
            compilecache &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;--compilecache=&amp;#34;&lt;/span&gt; &lt;span class=&#34;sfa0&#34;&gt;*&lt;/span&gt; (&lt;span class=&#34;s3ee&#34;&gt;Bool&lt;/span&gt;(Base&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;JLOptions()&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;use_compilecache) &lt;span class=&#34;sfa0&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;yes&amp;#34;&lt;/span&gt; &lt;span class=&#34;sfa0&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sc1c&#34;&gt;&amp;#34;no&amp;#34;&lt;/span&gt;)
            julia_exe &lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt; Base&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;julia_cmd()
            run(&lt;span class=&#34;sc1c&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;sc27&#34;&gt;$julia_exe&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt; --check-bounds=yes &lt;/span&gt;&lt;span class=&#34;sc27&#34;&gt;$codecov&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt; &lt;/span&gt;&lt;span class=&#34;sc27&#34;&gt;$color&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt; &lt;/span&gt;&lt;span class=&#34;sc27&#34;&gt;$compilecache&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt; &lt;/span&gt;&lt;span class=&#34;sc27&#34;&gt;$test_path&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;`&lt;/span&gt;)
            info(&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;sc27&#34;&gt;$module_file&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt; tests passed&amp;#34;&lt;/span&gt;)
        &lt;span class=&#34;s3e8&#34;&gt;catch&lt;/span&gt; err
            Base&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;Pkg&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;Entry&lt;span class=&#34;sfa0&#34;&gt;.&lt;/span&gt;warnbanner(err, label&lt;span class=&#34;sfa0&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt;&amp;#34;[ ERROR: &lt;/span&gt;&lt;span class=&#34;sc27&#34;&gt;$module_file&lt;/span&gt;&lt;span class=&#34;sc1c&#34;&gt; ]&amp;#34;&lt;/span&gt;)
        &lt;span class=&#34;s3e8&#34;&gt;end&lt;/span&gt;
    &lt;span class=&#34;s3e8&#34;&gt;end&lt;/span&gt;
&lt;span class=&#34;s3e8&#34;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Compared to simply &lt;code&gt;include(&amp;quot;wherever-it-is/runtests.jl&amp;quot;)&lt;/code&gt;, this has the advantage of running a separate Julia process, so your workspace does not contaminate the test environment and in case of segfaults, the parent process won&amp;rsquo;t be affected.&lt;/p&gt;

&lt;p&gt;Hopefully, the code above will be obsolete once &lt;a href=&#34;https://github.com/StefanKarpinski/Pkg3.jl&#34;&gt;Pkg3&lt;/a&gt; is released, but until then it is a useful workaround.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;edit&lt;/strong&gt;: function above was corrupted during copy-paste, corrected.&lt;/p&gt;
</content>
  </entry>
  
</feed>
